# #!/usr/bin/env groovy
snippet #!
	#!/usr/bin/env groovy
snippet cl
	class ${1:`Filename()`} {
		${2}
	}
snippet ci
	class ${1:`Filename()`} implements ${2:Interface} {
		${2}
	}
snippet clx
	class ${1:`Filename()`} extends ${2:Class} {
		${2}
	}
# unittest in groovy
snippet tc
	class ${1:`Filename()`} extends ${2:GroovyTestCase} {
		void setUp() {
			${3}
		}
		void tearDown() {
			${4}
		}

		void testSomething() {
			fail("implement me")
		}
	}
# for spock unittest
snippet spec
	import spock.lang.Specification

	class ${1:`Filename()`} extends Specification {
		def "${2:spec story}"() {
			${3}
		}
	}
snippet main
	static main(args) {
		${1:// TODO: generate method stub}
	}
snippet pl
	println "${1}"
snippet if
	if (${1}) {
		${2}
	}
snippet elif
	else if (${1}) {
		${2}
	}
snippet el
	else {
		${1}
	}
snippet for
	for (${1} in ${2}) {
		${3}
	}
snippet sw
	switch(${1:val}) {
		case ${2:val} :
			${3:statement}
			break
	}
snippet clo
	def ${1:closureName} = { ${2:var} ->
		${3}
	}
snippet mt
	def ${1:methodName}(${2:args}) {
		${3}
	}
snippet var
	def ${1:var} = ${2}
snippet each
	${1:var}.each { ${2:var} ->
		${3}
	}
snippet times
	${1:var}.each { ${2:var} ->
		${3}
	}
# metaClass
snippet mc
	${1:Class}.metaClass.${2:methodName} = { ${3:args} ->
		${4}
	}
# for grails web framework
# redirect
snippet red action
	redirect(action: ${1:actionName})
snippet red controller&action
	redirect(controller: ${1:controllerName}, action: ${2:actionName})
# render
snippet rd text
	render "${1}"
snippet rd view&model
	render(view: "${1:viewName}", model: "${2:modelName}")
# render with contentType json
snippet rd json
	render(contentType: 'text/json') {
		${1}
	}
# render with contentType xml
snippet rd xml
	render(contentType: 'text/xml') {
		${1}
	}
# withCriteria
snippet wc
	${1:DomainClass}.withCriteria {
		${3}
	}
# withTransaction
snippet wt
	${1:DomainClass}.withTransaction { ${2:status} ->
		${3}
	}
